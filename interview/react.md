<!--
 * @Author: hf
 * @Date: 2021-09-07 10:15:57
 * @LastEditTime: 2021-09-13 14:33:08
 * @LastEditors: hf
-->
### 1. react 有什么坑点？
>1. jsx 做表达式判断的时候，需要强制为boolean类型，如：
```
render(){
    const b=0;
    return <div>
    {
        !!b&&<div>这是一段文本</div>
    }
    </div>
}
```
如果不使用!!b进行强转数据类型，会在页面里面输出0.
>2. 尽量不要在componentWillReceiveProps里使用setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃。（实际不是componentWillReceiveProps会无限重渲染，而是componentDidUpdate)
>3. 给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的props处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次ref这个props,然后以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有的时候去ref赋值后的属性会取到null。
>4. 遍历子节点的时候，不要用index作为组件的key进行传入

### 2. 怎么去设计一个组件封装
>1. 组件封装的目的是为了重用，提高开发效率和代码质量
>2. 低耦合，单一职责，可复用性，可维护性

### 3.react的虚拟dom是怎么实现的
>1. 首先说说为什么要使用Virtual Dom，因为操作真实的Dom耗费的性能代价太高，所以react内部使用js实现了一套dom结构，在每次操作真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化 的dom节点，然后对其进行更新操作。
>2. 为了实现虚拟Dom,我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop,每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop 是否有更新，假如有prop不一样，那么react判定该节点有更新，那么重渲染该节点，然后在对其节点进行比较，一层一层往下，直到没有子节点。    

### 4. react hooks 原理是什么？
    hooks 是用闭包实现的，因为纯函数不能记住状态，只能通过闭包来实现。
### 5. useState 中的状态是怎么存储的
    通过单向链表，fiber tree就是一种单向链表的树形结构。
### 6.如何遍历一个dom树

```
        function traversal(node){
            //对node的处理
            if(node && node.nodeType === 1){
                console.log(node.tagName)
            }
            var i=0,
                childNodes = node.childNodes,
                item;
            for(;i<childNodes.length;i++){
                item = childNodes[i];
                if(item.nodeType === 1){
                    traversal(item)
                }
            }
        }
  ```

### 7. 数据双向绑定和单向绑定的优缺点
>1. 双向绑定是自动管理状态的，对处理有用户交互的场景非常合适，代码量少，当项目越来越大的时候，调试也变的越来越复杂，难以跟踪问题。
>2. 单向绑定是无状态的，程序调试相对容易，可以避免程序复杂度上升时产生的各种问题，当然写代码时就没有双向绑定那么简单方便了。

### 8. 解释React中render()的目的
>1. 每个react组件强制要求必须有一个render()。它返回一个React元素，是原生DOM组件的标示。如果需要渲染多个HTML元素，则必须将它们组合在一个封闭标记内。此函数必须保持纯净，即必须每次调用时都返回相同的结果。

### 9. 调用setState之后发生了什么？
>1. 在代码中调用setState函数之后，React会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程。
>2. 经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面。
>3. 在React得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重新渲染。
>4. 在差异计算算法中，React 能够相对精确的知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。

### 10. 触发多次setState,那么render会执行几次？
>1. 多次执行setState会合并为一次render,因为setState并不会立即改变state的值，而是将其放到一个任务队列里，最终将多个setState合并，一次性更新页面。
>2. 所以我们可以在代码里多次调用setState，每次只需要关注当前修改的字段即可。

### 11. react 中如何对state中的数据进行修改？setState为什么是异步的？
>1. 修改数据通过this.setState(参数1，参数2)
>2. this.setState是一个异步函数  
    -  参数1：需要修改的数据是一个对象    
    -  参数2：是一个回调函数，可以用来验证数据是否修改成功，同时可以获取到数据更新后的DOM结构等同于componentDidMount。
>3. this.setState中的第一个参数除了可以写成一个对象以外，还可以写成一个函数，函数中第一个值为prevState,第二个值为preProps,this.setState((prevState,prop)=>({}))   
#### 1.为什么建议传递setState的参数是一个callback而不是一个对象？
> 1. 因为this.props和this.state的更新可能是异步的，不能依赖他们的值去计算下一个state.
#### 2.为什么setState是一个异步？
> 1. 当批量执行state的时候可以让Dom渲染的更快，也就是说多个setState在执行的过程中还需要被合并。
### 12. 原生事件和react事件的区别?
> 1. react 事件使用驼峰命名，而不是全部小写。
> 2. 通过JSX,你传递一个函数作为事件处理程序，而不是一个字符串。
> 3. 在React中你不能通过返回false 来阻止默认行为。必须明确调用preventDefault。
### 13. React的合成事件是什么？
> 1. React根据W3C规范定义了每个事件处理函数的参数，即合成事件。
> 2. 事件处理程序将传递SyntheticEvent的实例，这是一个跨浏览器原生事件包装器。他具有与浏览器原生事件相同的接口，包括stopPropagation()和preventDefault()，在所有浏览器中他们工作方式都相同。
> 3. react合成的SyntheticEvent采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。
> 4. 另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。
### 14.什么是高阶组件（HOC)
> 高阶组件是重用组件逻辑的高级方法，是一种源于React的组件模式。HOC是自定义组件，在他之内包含另一个组件。他们可以接受子组件的任何动态，但不会修改或复制其输入组件中的任何行为，可以认为HOC是”纯“组件。
### 15.你能用HOC做什么？
    HOC可用于许多任务，例如：
    - 代码重用，逻辑和引导抽象
    - 渲染劫持
    - 状态抽象和控制
    - Props控制
### 16.react-router里的Link标签和a标签有什么区别？
    从DOM渲染来看，这两者都是链接，都是a标签。区别是：
    - Link是react-router里实现路由跳转的链接，配合Route使用，react-router拦截了其默认的链接跳转行为，区别于传统的页面跳转。
    - Link的”跳转"行为只会触发相匹配的Route对应的页面内容更新，而不会刷新整个页面。a标签是HTML原生的超链接，用于跳转的href指向的另一个页面或锚点元素，跳转新页面会刷新页面。
### 17.react-hooks的优劣如何？
    优点：
> 1. 简介：React Hooks 解决了HOC和render props的嵌套问题，更加简介。
> 2. 解耦：React Hooks 可以更方便地把UI和状态分离，做到更彻底的解耦。
> 3. 组合：Hooks 中可以引用另外的hooks形成新的Hooks,组合变化万千。
> 4. 函数友好：React Hooks 为函数组件而生，从而解决了类组件的几大问题：
    - this 指向容易错误
    - 分割在不同声明周期中的逻辑使得代码难以理解和维护
    - 代码复用成本高(高阶组件容易使代码量剧增)
  缺点:
> 1. 额外的学习成本（Function Component 与 Class Component之间的困惑）。
> 2. 写法上的限制（不能出在条件、循环中），并且写法限制增加了重构成本。
> 3. 破坏了PureComponent、 React.memo浅比较的性能性能优化效果（为了取最新的props 和 state,每次render()都要重新创建事件处函数）
> 4. 在闭包场景可能会引用到旧的state、props值。
> 5. 内部实现上不直观（依赖一份可变的全局状态，不再那么”纯“）
> 6. React.memo并不能完全替代shouldComponentUpdate(因为拿不到state Change,只针对props Change)
### 18.什么是React Fiber? 
> React fiber 是一种基于浏览器的单线程调度算法。   
React 16之前，reconcilation 算法实际上是递归，想要中断递归是很困难的，React16开始使用了循环来代替之前的递归。   
Fiber : 一种将reconcilation（递归diff),拆分成无数个小任务的算法；他随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms)内，还有没有足够的时间允许计算。   
### 19.diff算法大致的机制?
> 为了实现虚拟Dom,我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop,每次进行diff的时候，react会先比较该节点类型，假如节点类型不一样，那么react会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较prop 是否有更新，假如有prop不一样，那么react判定该节点有更新，那么重渲染该节点，然后在对其节点进行比较，一层一层往下，直到没有子节点。
### 20.如何实现react-router的hash-router?
> [解析](https://juejin.cn/post/6844904174774124557)
### 21.setState为什么是异步，在什么情况下会合并多个setState?
#### 21-1.setState到底是异步还是同步?
>答：有时是异步的，有时是同步的。
>1. setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout中都是同步的
>2. setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数setState(partialState,callback)中的callback拿到更新后的结果。
>3. setState的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。
### 22.为什么要用redux而不把数据放在window对象下?
### 23.redux的工作流程？
>[解析](https://juejin.cn/post/6844903922453200904#heading-12)
### 24.react-redux是如何工作的？
### 25.redux 和 mobx 的区别？
### 26. redux 异步中间件之间的优劣？
### 27.为什么选择使用框架而不是原生？
> 1. 组件化 ： 其中以React的组件化最为彻底，甚至可以到函数级别的原子组件，高度的组件化可以使我们的工程易于维护、易于组合拓展。
> 2. 天然分层：JQuery时代的代码大部分情况下是面条代码，耦合严重，现代框架不管是MVC、MVP还是MVVM模式都能帮助我们进行分层，代码解耦更易于读写。
> 3. 生态：现在主流前端框架都自带生态，不管是数据流管理架构还是UI库都有成熟的解决方案。
> 4. 开发效率：现代前端框架都默认自动更新DOM,而非我们手动操作，解放了开发者的手动DOM成本，提高了开发效率，从根本上解决了UI与状态同步问题。
